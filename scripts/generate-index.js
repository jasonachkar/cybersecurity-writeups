/**
 * @fileoverview Generates an index section for the root README.md by scanning docs/**/README.md files.
 * The script updates README.md only between the markers:
 *   <!-- AUTOGENERATED_INDEX_START -->
 *   <!-- AUTOGENERATED_INDEX_END -->
 *
 * It uses YAML-like front matter at the top of each README.md:
 * ---
 * title: "..."
 * type: tutorial|research|certification-notes
 * tags: [A, B, C]
 * date: 2024-12
 * readingTime: 12
 * ---
 *
 * No external dependencies required.
 */

const fs = require("fs");
const path = require("path");

const REPO_ROOT = path.resolve(__dirname, "..");
const DOCS_DIR = path.join(REPO_ROOT, "docs");
const ROOT_README = path.join(REPO_ROOT, "README.md");

const START_MARKER = "<!-- AUTOGENERATED_INDEX_START -->";
const END_MARKER = "<!-- AUTOGENERATED_INDEX_END -->";

const TYPE_ORDER = ["tutorial", "research", "certification-notes"];
const TYPE_LABELS = {
  tutorial: "ðŸ“˜ Tutorials",
  research: "ðŸ”¬ Research",
  "certification-notes": "ðŸŽ“ Certification Notes",
};

const DEFAULTS = {
  type: "tutorial",
  tags: [],
  date: "",
  readingTime: "",
};

/**
 * Recursively finds all README.md files under docs/ that are not under docs/assets.
 * @param {string} dir
 * @returns {string[]}
 */
function findWriteupReadmes(dir) {
  if (!fs.existsSync(dir)) return [];

  /** @type {string[]} */
  const results = [];

  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    const full = path.join(dir, entry.name);

    // Skip assets
    if (full.includes(`${path.sep}assets${path.sep}`)) continue;

    if (entry.isDirectory()) {
      results.push(...findWriteupReadmes(full));
      continue;
    }

    if (entry.isFile() && entry.name.toLowerCase() === "readme.md") {
      results.push(full);
    }
  }

  return results;
}

/**
 * Parses simple YAML-like front matter.
 * Supports:
 * - title: "..."
 * - type: tutorial
 * - date: 2024-12
 * - readingTime: 12
 * - tags: [A, B, C]   (or tags: ["A","B"])
 *
 * @param {string} content
 * @returns {{ frontMatter: Record<string, any>, body: string }}
 */
function parseFrontMatter(content) {
  const trimmed = content.trimStart();

  if (!trimmed.startsWith("---")) {
    return { frontMatter: {}, body: content };
  }

  const endIndex = trimmed.indexOf("\n---", 3);
  if (endIndex === -1) {
    return { frontMatter: {}, body: content };
  }

  const fmBlock = trimmed.slice(3, endIndex).trim();
  const body = trimmed.slice(endIndex + "\n---".length).trimStart();

  /** @type {Record<string, any>} */
  const fm = {};

  const lines = fmBlock
    .split("\n")
    .map((l) => l.trim())
    .filter((l) => l.length > 0 && !l.startsWith("#"));

  for (const line of lines) {
    const colonIndex = line.indexOf(":");
    if (colonIndex === -1) continue;

    const key = line.slice(0, colonIndex).trim();
    let value = line.slice(colonIndex + 1).trim();

    // Strip surrounding quotes
    const stripQuotes = (v) => {
      if (
        (v.startsWith('"') && v.endsWith('"')) ||
        (v.startsWith("'") && v.endsWith("'"))
      ) {
        return v.slice(1, -1);
      }
      return v;
    };

    // tags: [a, b, c]
    if (key === "tags") {
      // Basic bracket list parse
      const bracketMatch = value.match(/^\[(.*)\]$/);
      if (bracketMatch) {
        const inside = bracketMatch[1].trim();
        if (!inside) {
          fm.tags = [];
        } else {
          // Split by comma not inside quotes (simple approach)
          const parts = inside.split(",").map((p) => stripQuotes(p.trim()));
          fm.tags = parts.filter(Boolean);
        }
      } else {
        fm.tags = [stripQuotes(value)];
      }
      continue;
    }

    // numeric fields
    if (key === "readingTime") {
      const n = Number(stripQuotes(value));
      fm.readingTime = Number.isFinite(n) ? n : stripQuotes(value);
      continue;
    }

    fm[key] = stripQuotes(value);
  }

  return { frontMatter: fm, body };
}

/**
 * Normalizes and validates metadata.
 * @param {Record<string, any>} fm
 * @returns {{ title: string, type: string, tags: string[], date: string, readingTime: string|number }}
 */
function normalizeMeta(fm) {
  const type = String(fm.type || DEFAULTS.type).trim();
  const normalizedType = TYPE_ORDER.includes(type) ? type : DEFAULTS.type;

  const title = String(fm.title || "").trim();
  const tags = Array.isArray(fm.tags) ? fm.tags.map(String) : DEFAULTS.tags;

  const date = String(fm.date || "").trim();
  const readingTime = fm.readingTime ?? DEFAULTS.readingTime;

  return {
    title,
    type: normalizedType,
    tags,
    date,
    readingTime,
  };
}

/**
 * Builds a Markdown list item for an entry.
 * @param {{ title: string, type: string, tags: string[], date: string, readingTime: string|number }} meta
 * @param {string} relativeDirPath
 * @returns {string}
 */
function buildEntryLine(meta, relativeDirPath) {
  const safeTitle = meta.title || path.basename(relativeDirPath);
  const link = relativeDirPath.replace(/\\/g, "/"); // windows-safe
  const tagPreview = meta.tags && meta.tags.length > 0 ? meta.tags.slice(0, 4).join(", ") : "";
  const tagSuffix =
    meta.tags && meta.tags.length > 4 ? ` (+${meta.tags.length - 4})` : "";

  const datePart = meta.date ? ` Â· ${meta.date}` : "";
  const timePart =
    meta.readingTime !== "" && meta.readingTime !== undefined
      ? ` Â· ${meta.readingTime} min`
      : "";

  const metaPart =
    tagPreview || datePart || timePart
      ? ` â€” ${tagPreview}${tagSuffix}${datePart}${timePart}`.trim()
      : "";

  return `- [${safeTitle}](${link})${metaPart ? ` ${metaPart}` : ""}`;
}

/**
 * Generates the index section markdown.
 * @param {Array<{ meta: ReturnType<typeof normalizeMeta>, relDir: string }>} items
 * @returns {string}
 */
function generateIndexMarkdown(items) {
  /** @type {Record<string, Array<{ meta: any, relDir: string }>>} */
  const grouped = {
    tutorial: [],
    research: [],
    "certification-notes": [],
  };

  for (const it of items) {
    grouped[it.meta.type].push(it);
  }

  // Sort each group by date desc then title asc
  const dateValue = (d) => {
    // Accept YYYY-MM or YYYY-MM-DD; fallback to 0
    const normalized = String(d || "");
    if (!normalized) return 0;
    // Convert to comparable number: YYYYMMDD-ish
    const parts = normalized.split("-");
    const y = Number(parts[0] || 0);
    const m = Number(parts[1] || 1);
    const day = Number(parts[2] || 1);
    return y * 10000 + m * 100 + day;
  };

  for (const type of Object.keys(grouped)) {
    grouped[type].sort((a, b) => {
      const da = dateValue(a.meta.date);
      const db = dateValue(b.meta.date);
      if (da !== db) return db - da;
      const ta = (a.meta.title || "").toLowerCase();
      const tb = (b.meta.title || "").toLowerCase();
      return ta.localeCompare(tb);
    });
  }

  const lines = [];
  lines.push("## ðŸ“š Index");
  lines.push("");
  lines.push("_This section is autogenerated. Do not edit entries here directly; update each writeupâ€™s front matter instead._");
  lines.push("");

  for (const type of TYPE_ORDER) {
    const label = TYPE_LABELS[type];
    const group = grouped[type];

    if (!group || group.length === 0) continue;

    lines.push(`### ${label}`);
    lines.push("");

    for (const entry of group) {
      lines.push(buildEntryLine(entry.meta, entry.relDir));
    }

    lines.push("");
  }

  return lines.join("\n").trimEnd();
}

/**
 * Inserts or replaces content between markers in the root README.
 * @param {string} readmeContent
 * @param {string} generated
 * @returns {string}
 */
function upsertBetweenMarkers(readmeContent, generated) {
  if (!readmeContent.includes(START_MARKER) || !readmeContent.includes(END_MARKER)) {
    const defaultBlock = [
      "",
      START_MARKER,
      generated,
      END_MARKER,
      "",
    ].join("\n");

    return readmeContent.trimEnd() + defaultBlock;
  }

  const startIdx = readmeContent.indexOf(START_MARKER);
  const endIdx = readmeContent.indexOf(END_MARKER);

  if (startIdx === -1 || endIdx === -1 || endIdx < startIdx) {
    throw new Error("Invalid markers in README.md");
  }

  const before = readmeContent.slice(0, startIdx + START_MARKER.length);
  const after = readmeContent.slice(endIdx);

  // Ensure clean spacing
  return `${before}\n${generated}\n${after}`;
}

function main() {
  if (!fs.existsSync(DOCS_DIR)) {
    console.error(`docs/ directory not found at: ${DOCS_DIR}`);
    process.exit(1);
  }

  const readmes = findWriteupReadmes(DOCS_DIR);

  /** @type {Array<{ meta: any, relDir: string }>} */
  const items = [];

  for (const filePath of readmes) {
    const raw = fs.readFileSync(filePath, "utf8");
    const { frontMatter } = parseFrontMatter(raw);
    const meta = normalizeMeta(frontMatter);

    // We index folders, not file links, so link to the directory
    const dir = path.dirname(filePath);
    const relDir = path.relative(REPO_ROOT, dir);

    // Skip if no title and it's the root docs folder (rare)
    items.push({ meta, relDir });
  }

  const generated = generateIndexMarkdown(items);

  if (!fs.existsSync(ROOT_README)) {
    // If no README exists, create a minimal one with markers
    const minimal = [
      "# Cybersecurity Writeups & Learning",
      "",
      "Personal writeups, tutorials, and notes from my cybersecurity journey.",
      "",
      START_MARKER,
      generated,
      END_MARKER,
      "",
    ].join("\n");

    fs.writeFileSync(ROOT_README, minimal, "utf8");
    console.log("Created README.md with autogenerated index.");
    return;
  }

  const current = fs.readFileSync(ROOT_README, "utf8");
  const updated = upsertBetweenMarkers(current, generated);

  if (updated !== current) {
    fs.writeFileSync(ROOT_README, updated, "utf8");
    console.log("Updated README.md index.");
  } else {
    console.log("README.md index is already up to date.");
  }
}

main();
