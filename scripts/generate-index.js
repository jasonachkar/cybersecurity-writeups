/**
 * @fileoverview Generates an index section for the root README.md by scanning docs README.md files.
 * The script updates README.md only between the markers:
 *   <!-- AUTOGENERATED_INDEX_START -->
 *   <!-- AUTOGENERATED_INDEX_END -->
 *
 * It uses YAML-like front matter at the top of each README.md:
 * ---
 * title: "..."
 * type: tutorial|research|certification-notes
 * tags: [A, B, C]
 * date: 2024-12
 * readingTime: 12
 * ---
 *
 * No external dependencies required.
 */

//#region Imports
const fs = require("fs");
const path = require("path");
//#endregion

//#region Constants

// Paths

/* Repository root */
const REPO_ROOT = path.resolve(__dirname, "..");

/* Docs directory path */
const DOCS_DIR = path.join(REPO_ROOT, "docs");

/* README path */
const ROOT_README = path.join(REPO_ROOT, "README.md");

// Markers
/* Markers for autogenerated index in README */
const START_MARKER = "<!-- AUTOGENERATED_INDEX_START -->";
const END_MARKER = "<!-- AUTOGENERATED_INDEX_END -->";

// Types
/* Supported writeup types and their labels */
const TYPE_ORDER = ["tutorial", "research", "certification-notes"];
const TYPE_LABELS = {
  tutorial: "ðŸ“˜ Tutorials",
  research: "ðŸ”¬ Research",
  "certification-notes": "ðŸŽ“ Certification Notes",
};

/* Default metadata values */
const DEFAULTS = {
  type: "tutorial",
  tags: [],
  date: "",
  readingTime: "",
};
//#endregion

// Note: This script is intended to be readable and maintainable by
// contributors. The comments sprinkled through the functions explain
// assumptions about repository layout, front matter structure, and
// formatting choices made for the generated index entries.

/**
 * Recursively finds all README.md files under docs/ that are not under docs/assets.
 * @param {string} dir
 * @returns {string[]}
 */
function findWriteupReadmes(dir) {
  if (!fs.existsSync(dir)) return [];

  /** @type {string[]} */
  const results = [];

  // Read directory entries
  const entries = fs.readdirSync(dir, { withFileTypes: true });

  // Process each entry
  for (const entry of entries) {
    // Full path of the entry
    const full = path.join(dir, entry.name);

    // Skip any `assets` directory and its descendants.
    // `assets/` folders commonly contain images or other binary
    // blobs that are not authored writeups and do not include
    // front matter; indexing them would be noisy.
    if (full.includes(`${path.sep}assets${path.sep}`)) continue;

    // Recurse into directories
    if (entry.isDirectory()) {
      // Recurse
      results.push(...findWriteupReadmes(full));
      continue;
    }

    // Check for README.md files
    if (entry.isFile() && entry.name.toLowerCase() === "readme.md") {
      results.push(full);
    }
  }

  // Return the list of README.md files
  return results;
}

/**
 * Parses simple YAML-like front matter.
 * Supports:
 * - title: "..."
 * - type: tutorial
 * - date: 2024-12
 * - readingTime: 12
 * - tags: [A, B, C]   (or tags: ["A","B"])
 *
 * @param {string} content
 * @returns {{ frontMatter: Record<string, any>, body: string }}
 */
function parseFrontMatter(content) {
  // Trim leading whitespace
  const trimmed = content.trimStart();

  // Check for starting ---
  // If the file doesn't begin with a `---` front-matter block we
  // assume there is no structured metadata and return an empty
  // frontMatter object along with the full content as the body.
  if (!trimmed.startsWith("---")) {
    return { frontMatter: {}, body: content };
  }

  // Find the closing `---` delimiter. We look for a newline then
  // `---` to reduce accidental matches; if not found we again
  // treat the file as having no valid front matter.
  const endIndex = trimmed.indexOf("\n---", 3);
  if (endIndex === -1) {
    return { frontMatter: {}, body: content };
  }

  // Extract front matter block and body
  const fmBlock = trimmed.slice(3, endIndex).trim();

  // Extract body
  const body = trimmed.slice(endIndex + "\n---".length).trimStart();

  /** @type {Record<string, any>} */
  const fm = {};

  // Parse lines
  const lines = fmBlock
    .split("\n")
    .map((l) => l.trim())
    .filter((l) => l.length > 0 && !l.startsWith("#"));

  // Simple key: value parsing
  for (const line of lines) {
    const colonIndex = line.indexOf(":");
    if (colonIndex === -1) continue;

    // Split key and value
    const key = line.slice(0, colonIndex).trim();

    // Parse value
    let value = line.slice(colonIndex + 1).trim();

    // Strip surrounding quotes
    const stripQuotes = (v) => {
      if (
        (v.startsWith('"') && v.endsWith('"')) ||
        (v.startsWith("'") && v.endsWith("'"))
      ) {
        return v.slice(1, -1);
      }
      return v;
    };

    // tags: [a, b, c]
    if (key === "tags") {
      // Basic bracket list parse
      const bracketMatch = value.match(/^\[(.*)\]$/);
      if (bracketMatch) {
        const inside = bracketMatch[1].trim();
        if (!inside) {
          fm.tags = [];
        } else {
          // Lightweight parsing of the comma-separated tag list.
          // This handles simple cases like: [a, b, c] or ["a", "b"].
          // It does not attempt to be a full YAML parser (no support
          // for escaped commas inside quoted strings or nested lists),
          // which keeps the implementation dependency-free and
          // predictable for our authors.
          const parts = inside.split(",").map((p) => stripQuotes(p.trim()));
          fm.tags = parts.filter(Boolean);
        }
      } else {
        fm.tags = [stripQuotes(value)];
      }
      continue;
    }

    // numeric fields
    if (key === "readingTime") {
      const n = Number(stripQuotes(value));
      fm.readingTime = Number.isFinite(n) ? n : stripQuotes(value);
      continue;
    }

    // Default: store as string
    fm[key] = stripQuotes(value);
  }

  return { frontMatter: fm, body };
}

/**
 * Normalizes and validates metadata.
 * @param {Record<string, any>} fm
 * @returns {{ title: string, type: string, tags: string[], date: string, readingTime: string|number }}
 */
function normalizeMeta(fm) {
  // Type normalization
  const type = String(fm.type || DEFAULTS.type).trim();

  // Validate type
  const normalizedType = TYPE_ORDER.includes(type) ? type : DEFAULTS.type;

  // Title
  const title = String(fm.title || "").trim();
  // Tags
  const tags = Array.isArray(fm.tags) ? fm.tags.map(String) : DEFAULTS.tags;

  // Date
  const date = String(fm.date || "").trim();

  // Reading time
  const readingTime = fm.readingTime ?? DEFAULTS.readingTime;

  // Return normalized metadata
  return {
    title,
    type: normalizedType,
    tags,
    date,
    readingTime,
  };
}

/**
 * Builds a Markdown list item for an entry.
 * @param {{ title: string, type: string, tags: string[], date: string, readingTime: string|number }} meta
 * @param {string} relativeDirPath
 * @returns {string}
 */
function buildEntryLine(meta, relativeDirPath) {
  // Use directory name as fallback title
  const safeTitle = meta.title || path.basename(relativeDirPath);
  // Create link (relative path)
  const link = relativeDirPath.replace(/\\/g, "/"); // windows-safe
  // Build metadata parts
  const tagPreview =
    meta.tags && meta.tags.length > 0 ? meta.tags.slice(0, 4).join(", ") : "";

  // Suffix for extra tags
  const tagSuffix =
    meta.tags && meta.tags.length > 4 ? ` (+${meta.tags.length - 4})` : "";

  // Date part
  const datePart = meta.date ? ` Â· ${meta.date}` : "";

  // Reading time part
  const timePart =
    meta.readingTime !== "" && meta.readingTime !== undefined
      ? ` Â· ${meta.readingTime} min`
      : "";

  // Combine meta parts
  // We show a short preview of tags (up to 4), then the date and
  // reading time if available. Extra tags are summarized with a
  // `(+N)` suffix to keep the line length reasonable.
  const metaPart =
    tagPreview || datePart || timePart
      ? ` â€” ${tagPreview}${tagSuffix}${datePart}${timePart}`.trim()
      : "";

  // Build final line
  return `- [${safeTitle}](${link})${metaPart ? ` ${metaPart}` : ""}`;
}

/**
 * Generates the index section markdown.
 * @param {Array<{ meta: ReturnType<typeof normalizeMeta>, relDir: string }>} items
 * @returns {string}
 */
function generateIndexMarkdown(items) {
  /** @type {Record<string, Array<{ meta: any, relDir: string }>>} */
  const grouped = {
    tutorial: [],
    research: [],
    "certification-notes": [],
  };

  // Group items by type
  for (const it of items) {
    grouped[it.meta.type].push(it);
  }

  // Sort each group by date desc then title asc
  const dateValue = (d) => {
    // Accept YYYY-MM or YYYY-MM-DD; fallback to 0
    const normalized = String(d || "");
    if (!normalized) return 0;
    // Convert to comparable number: YYYYMMDD-ish
    const parts = normalized.split("-");
    
    // Pad parts
    const y = Number(parts[0] || 0);

    // Months and days default to 1
    const m = Number(parts[1] || 1);

    // Days default to 1
    const day = Number(parts[2] || 1);

    // Return combined value
    return y * 10000 + m * 100 + day;
  };

  for (const type of Object.keys(grouped)) {
    grouped[type].sort((a, b) => {
      const da = dateValue(a.meta.date);
      const db = dateValue(b.meta.date);
      if (da !== db) return db - da;
      const ta = (a.meta.title || "").toLowerCase();
      const tb = (b.meta.title || "").toLowerCase();
      return ta.localeCompare(tb);
    });
  }

  const lines = [];
  lines.push("## ðŸ“š Index");
  lines.push("");
  lines.push(
    "_This section is autogenerated. Do not edit entries here directly; update each writeupâ€™s front matter instead._"
  );
  lines.push("");

  for (const type of TYPE_ORDER) {
    const label = TYPE_LABELS[type];
    const group = grouped[type];

    if (!group || group.length === 0) continue;

    lines.push(`### ${label}`);
    lines.push("");

    for (const entry of group) {
      lines.push(buildEntryLine(entry.meta, entry.relDir));
    }

    lines.push("");
  }

  return lines.join("\n").trimEnd();
}

/**
 * Inserts or replaces content between markers in the root README.
 * @param {string} readmeContent
 * @param {string} generated
 * @returns {string}
 */
function upsertBetweenMarkers(readmeContent, generated) {
  if (
    !readmeContent.includes(START_MARKER) ||
    !readmeContent.includes(END_MARKER)
  ) {
    const defaultBlock = ["", START_MARKER, generated, END_MARKER, ""].join(
      "\n"
    );

    return readmeContent.trimEnd() + defaultBlock;
  }

  const startIdx = readmeContent.indexOf(START_MARKER);
  const endIdx = readmeContent.indexOf(END_MARKER);

  if (startIdx === -1 || endIdx === -1 || endIdx < startIdx) {
    throw new Error("Invalid markers in README.md");
  }

  const before = readmeContent.slice(0, startIdx + START_MARKER.length);
  const after = readmeContent.slice(endIdx);

  // Ensure clean spacing
  return `${before}\n${generated}\n${after}`;
}

function main() {
  if (!fs.existsSync(DOCS_DIR)) {
    console.error(`docs/ directory not found at: ${DOCS_DIR}`);
    process.exit(1);
  }

  const readmes = findWriteupReadmes(DOCS_DIR);

  /** @type {Array<{ meta: any, relDir: string }>} */
  const items = [];

  for (const filePath of readmes) {
    const raw = fs.readFileSync(filePath, "utf8");
    const { frontMatter } = parseFrontMatter(raw);
    const meta = normalizeMeta(frontMatter);

    // We index folders, not file links, so link to the directory
    const dir = path.dirname(filePath);
    const relDir = path.relative(REPO_ROOT, dir);

    // We include the item even if title is missing; `buildEntryLine`
    // will fall back to the directory name. This keeps the index
    // comprehensive even when metadata is incomplete. If you want
    // to exclude a folder from indexing, add a note in its README
    // or remove the README front matter instead.
    items.push({ meta, relDir });
  }

  const generated = generateIndexMarkdown(items);

  if (!fs.existsSync(ROOT_README)) {
    // If no README exists, create a minimal one with markers
    const minimal = [
      "# Cybersecurity Writeups & Learning",
      "",
      "Personal writeups, tutorials, and notes from my cybersecurity journey.",
      "",
      START_MARKER,
      generated,
      END_MARKER,
      "",
    ].join("\n");

    fs.writeFileSync(ROOT_README, minimal, "utf8");
    console.log("Created README.md with autogenerated index.");
    return;
  }

  const current = fs.readFileSync(ROOT_README, "utf8");
  const updated = upsertBetweenMarkers(current, generated);

  if (updated !== current) {
    fs.writeFileSync(ROOT_README, updated, "utf8");
    console.log("Updated README.md index.");
  } else {
    console.log("README.md index is already up to date.");
  }
}

main();
